- Создаем класс ноды: мин, макс и текущее значение
- Создаем массив нод размером n. Дальше все операции будем делать с массивом. Так будет проще получать
медиану. Тут еще вопрос, нужно ли будет постоянно получать ее?
- Закидываем все ноды в массив и устанавливаем текущие значения - минимальными. При этом ведем счетчик
оставшихся к распределению баллов
- Сортируем массив по текущим значениям
- (1) Добавляем баллы к среднему элементу с учетом ограничения и оставшихся баллов
- Если средний стал больше чем следующих - меняем местами и дальше пузырьком элемент плывет на своем
место, таким образом массив всегда отсортирован
- Если поднять больше не можем - уперлись в верхнее ограничение - то тут вопрос: с кем его поменять
местами? Направо не можем сдвинуть. Выходит налево.
- Нужно левую половину массива выгрузить в отдельный массив и отсортировать по верхней границе, т.о.
получим перспективных кандидатов к росту.
- Подобрать подходящего к замене кандидата с учетом ограничений - сможем ли мы медианный сдвинуть так
влево?
- После замены - перейти к шагу (1) и повторять итерации

Варинт, предложенный ботом :)
1. Отсортировать список оценок по возрастанию.
2. Определить медиану в зависимости от четности/нечетности количества оценок.
3. Если медиана уже максимальна или ниже заданного ограничения, то все оценки остаются без изменений.
4. Если медиана выше заданного ограничения, то перебрать оценки сначала самых высоких, пока не достигнута медиана.
5. Записывать выбранным оценкам максимальный возможный бал, который не превышает заданного ограничения.
6. Если при достижении медианы все оценки уже выбраны, то все оставшиеся оценки также записать максимальным возможным баллом, который не превышает заданного ограничения.
7. Вывести новый список оценок.
